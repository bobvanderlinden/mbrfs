cmake_minimum_required(VERSION 3.5.1)
project("mbrfs")
set(PROJECT_DESCRIPTION "A FUSE-filesystem that provides the partitions from a disk device or image.")

set(CMAKE_MODULE_PATH "${CMAKE_MODULE_PATH}" "${CMAKE_SOURCE_DIR}/cmake")
include(CheckSymbolExists)
include(FindPkgConfig)
include(GNUInstallDirs)

set(PROJECT_VERSION_MAJOR 0)
set(PROJECT_VERSION_MINOR 1)
set(PROJECT_VERSION "${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}")

if(${CMAKE_VERSION} VERSION_GREATER "3.12") 
	set(CMAKE_CXX_STANDARD 20)
else()
	if(${CMAKE_VERSION} VERSION_GREATER "3.8") 
		set(CMAKE_CXX_STANDARD 17)
	else()
		set(CMAKE_CXX_STANDARD 14)
	endif()
endif()

set(CMAKE_C_STANDARD 11)

find_package(PkgConfig)

macro(findFuse desiredVersion)
	if(${desiredVersion} GREATER_EQUAL 3)
		set(libName "fuse${desiredVersion}")
	else()
		set(libName "fuse")
	endif()
	message(STATUS "Searching for FUSE ${desiredVersion} (${libName}) ...")
	pkg_check_modules(FUSE "${libName}")
	if(FUSE_FOUND)
		message(STATUS "Found FUSE 3. Libs: ${FUSE_LINK_LIBRARIES} . Includes: ${FUSE_INCLUDE_DIRS} . Flags: ${FUSE_CFLAGS_OTHER}")
	else()
		message(ERROR "Haven't found FUSE 3")
	endif()
endmacro()

if(NOT DEFINED FUSE_LINK_LIBRARIES OR NOT DEFINED FUSE_INCLUDE_DIRS)
	if(NOT DEFINED FUSE_DESIRED_VERSION)
		findFuse(3)
		if(NOT FUSE_FOUND)
			findFuse(2)
			if(NOT FUSE_FOUND)
				message(FATAL_ERROR "Haven't found any modern FUSE")
			endif()
		endif()
	else()
		findFuse("${FUSE_DESIRED_VERSION}")
	endif()
endif()


check_symbol_exists(setxattr "sys/xattr.h" HAVE_SETXATTR)
check_symbol_exists(utimensat "sys/stat.h" HAVE_UTIMENSAT)
check_symbol_exists(posix_fallocate "fcntl.h" HAVE_POSIX_FALLOCATE)
check_symbol_exists(itoa "stdlib.h" HAVE_ITOA)
check_symbol_exists(atoi "stdlib.h" HAVE_ATOI)
configure_file("${CMAKE_SOURCE_DIR}/config.h.in" "${CMAKE_SOURCE_DIR}/config.h")

add_executable(mbrfs "mbrfs.c")
target_include_directories(mbrfs PRIVATE "${CMAKE_SOURCE_DIR}" "${FUSE_INCLUDE_DIRS}")
target_link_libraries(mbrfs PRIVATE "${FUSE_LINK_LIBRARIES}")
target_compile_definitions(mbrfs PRIVATE "${FUSE_CFLAGS_OTHER}" "-DHAVE_CONFIG_H")

install(TARGETS mbrfs RUNTIME)

set(CPACK_PACKAGE_CHECKSUM "SHA512")
set(CPACK_GENERATOR "DEB")
set(CPACK_DEBIAN_COMPRESSION_TYPE "xz")
set(PROJECT_PACKAGE_VERSION "${PROJECT_VERSION}")
set(CPACK_PACKAGE_VENDOR "Bob van der Linden")
set(CPACK_PACKAGE_CONTACT "https://github.com/bobvanderlinden/mbrfs")
set(CPACK_PACKAGE_HOMEPAGE_URL "https://github.com/bobvanderlinden/mbrfs")

set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/LICENSE")
set(CPACK_RESOURCE_FILE_README "${CMAKE_CURRENT_SOURCE_DIR}/README.md")
set(CPACK_DEBIAN_PACKAGE_SHLIBDEPS ON)
set(CPACK_RPM_PACKAGE_AUTOREQ ON)

set(CPACK_DEBIAN_PACKAGE_NAME "mbrfs")
set(CPACK_DEBIAN_PACKAGE_MAINTAINER "${CPACK_PACKAGE_VENDOR}")
set(CPACK_PACKAGE_VERSION_MAJOR "${PROJECT_VERSION_MAJOR}")
set(CPACK_PACKAGE_VERSION_MINOR "${PROJECT_VERSION_MINOR}")
set(CPACK_PACKAGE_VERSION_PATCH "${PROJECT_VERSION_PATCH}")
set(CPACK_PACKAGE_VERSION_TWEAK "${PROJECT_VERSION_TWEAK}")
set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "${PROJECT_DESCRIPTION}")
set(CPACK_PACKAGE_DESCRIPTION "When creating images that hold a filesystem, I always needed to use root to create a loopback device. From the loopback device I could access the different partitions of that image. I did this in an automated build process and didn't like that it needed root. FUSE allows users to mount filesystems and with mbrfs you can get the functionality of dividing devices into partitions, like loopback devices have.")
set(CPACK_PACKAGE_DESCRIPTION_FILE "${CPACK_RESOURCE_FILE_README}")
set(CPACK_DEBIAN_PACKAGE_SECTION "admin")

include(CPack)
